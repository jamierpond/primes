
fn is_prime_with_optim(n: u32, primes_so_far: &Vec<u32>) -> bool {
    // Should not be getting even numbers at this point.
    for i in primes_so_far {
        if n % i == 0 {
            return false;
        }
    }


    let start_index = std::cmp::max(primes_so_far.len() - 1, 0);
    let start = primes_so_far[primes_so_far.len() - 1];
    let other_range = (primes_so_far[primes_so_far.len() - 1]..n).step_by(2);

    for i in other_range {
        if n % i == 0 {
            return false;
        }
    }

    return true;
}

fn is_prime(n: u32) -> bool {
    let vec: Vec<u32> = vec![];
    return is_prime_with_optim(n, &vec);
}

fn get_primes_to(n: u32) -> Vec<u32> {
    let mut primes: Vec<u32> = vec![2];
    let mut numbers_which_are_not_prime: Vec<u32> = vec![];

    for i in (3..n).step_by(2) {
        if numbers_which_are_not_prime.contains(&i) {
            continue;
        }

        if is_prime_with_optim(i, &primes) {
            primes.push(i);
        }

        else {
            let mut j = 0;
            loop {
                // Mark all multiples of i as not prime.
                let multiple = i * j;
                if multiple > n {
                    break;
                }
                j += 1;
                numbers_which_are_not_prime.push(multiple);
            }
        }
    }
    return primes;
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_primes() {
        assert_eq!(is_prime(1), false);
    }

    #[test]
    fn test_get_primes() {
        assert_eq!(get_primes_to(10), vec![2, 3, 5, 7]);
    }
}



fn main() {
    let primes = get_primes_to(100);
    println!("Primes: {:?}", primes);

    println!("Number of primes: {}", primes.len());
}
